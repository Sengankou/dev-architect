# Feature Specification: 対話フロー + セッション管理

**Feature Branch**: `002-chat-session`  
**Created**: 2025-10-25  
**Status**: Draft  
**Input**: User description: "Phase 2: 対話フロー + セッション管理

ユーザーとのマルチターン会話を実現し、要件を対話的に精緻化する機能を実装する。

主要機能:
1. /api/chat エンドポイント（POST）
2. セッションID単位でKVに会話履歴を保存
3. Mastraワークフローを会話対応に拡張
4. D1にsessions/messagesテーブルを追加
5. セッション復元機能

技術スタック:
- KVストレージ（セッション履歴）
- D1データベース（永続化）
- Mastra（会話文脈保持）
- Hono（API）"

## Clarifications

### Session 2025-10-25

- Q: D1永続化失敗時の挙動（Phase 1ではベストエフォート型でD1保存失敗時も200返却していたが、Phase 2でも継続するか？） → A: D1永続化失敗時もKV保存成功なら200返却（Phase 1ベストエフォート型継続）
- Q: 同時メッセージ送信時の競合制御（1セッション内で並行リクエストが発生した場合の整合性保証方法） → A: 楽観的並行制御（タイムスタンプ順序保証、競合検出なし）
- Q: メッセージ内容のサニタイゼーション（XSS/インジェクション攻撃対策） → A: UI表示時のみエスケープ（サーバー側はバリデーションのみ、UI側でHTMLエスケープ）
- Q: 観測可能性（ロギング・メトリクス要件） → A: Phase 1と同様の構造化ログ（Info/Error、セッションID・タイムスタンプ含む）、メトリクスはPhase 3以降

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 要件の対話的入力 (Priority: P1)

エンジニアリングマネージャーが、初回の要件入力後、AIとの対話を通じて要件を段階的に詳細化できる。単発のPOSTではなく、会話形式で要件を精緻化することで、不明瞭な点をその場で解消できる。

**Why this priority**: 本機能の中核価値。Phase 1では一度きりの要件入力だったが、Phase 2では対話を通じて要件の質を向上させることが最大の価値提供。

**Independent Test**: curlまたはHTTPクライアントで`POST /api/chat`に初回メッセージを送信し、セッションIDとAI応答が返ること、続けて同じセッションIDで追加メッセージを送信し、会話履歴が保持されていることを確認できる。

**Acceptance Scenarios**:

1. **Given** エンジニアリングマネージャーが新しいプロジェクトの要件を考えている、**When** `/api/chat`に初回メッセージ（要件の概要）を送信する、**Then** 新しいセッションIDが生成され、AIが要件を理解した上で明確化すべき点を質問するレスポンスが返される
2. **Given** 既存のセッションIDを持っている、**When** セッションIDを含めて追加メッセージ（質問への回答）を送信する、**Then** 過去の会話履歴を踏まえたAIの応答が返され、要件がさらに詳細化される
3. **Given** 複数回のやり取りで要件が十分に詳細化された、**When** 「仕様書を生成して」というメッセージを送信する、**Then** Phase 1で実装済みの`generateSpec`ワークフローが実行され、詳細化された要件から仕様書が生成される

---

### User Story 2 - セッションの永続化と復元 (Priority: P2)

エンジニアリングマネージャーが、過去の会話セッションを再開して、以前の文脈を保持したまま要件の追加議論や修正ができる。

**Why this priority**: ユーザー体験を大幅に向上させる機能。一度に要件を完成させる必要がなく、時間をかけて段階的に精緻化できる。ただし、P1なしでは意味がない。

**Independent Test**: 会話セッション作成後、ブラウザをリロードまたはAPIを再接続し、同じセッションIDで`POST /api/chat`を送信した際、過去の会話履歴が保持されており、文脈を理解した応答が返ることを確認できる。

**Acceptance Scenarios**:

1. **Given** 過去に作成した会話セッションIDを保持している、**When** 数時間後または翌日にそのセッションIDで新しいメッセージを送信する、**Then** 過去の会話履歴全体が読み込まれ、文脈を踏まえたAI応答が返される
2. **Given** 複数の異なるプロジェクトで会話セッションを作成している、**When** 特定のセッションIDを指定してメッセージを送信する、**Then** そのセッション固有の会話履歴のみが使用され、他のセッションと混同されない
3. **Given** 長期間アクセスしていないセッション（例: 数ヶ月前に作成）、**When** セッションIDを指定してアクセスする、**Then** 有効期限なしで永続的に保存されているため、過去の会話履歴全体が正常に読み込まれ、文脈を踏まえたAI応答が返される

---

### User Story 3 - 会話履歴の可視化 (Priority: P3)

エンジニアリングマネージャーが、過去の会話履歴を時系列で閲覧し、どのように要件が精緻化されていったかを確認できる。

**Why this priority**: 要件の変遷を追跡できる便利機能だが、対話機能自体（P1）とセッション復元（P2）があれば基本的な価値は提供できる。

**Independent Test**: `GET /api/chat/{sessionId}/history`で会話履歴全体をJSON形式で取得し、各メッセージのタイムスタンプ、送信者（ユーザー/AI）、内容が正しく返されることを確認できる。

**Acceptance Scenarios**:

1. **Given** 複数回のメッセージ交換があるセッション、**When** 会話履歴取得APIを呼び出す、**Then** すべてのメッセージが時系列順（古い順）で返され、各メッセージに送信者、内容、タイムスタンプが含まれる
2. **Given** 新規作成されたばかりのセッション、**When** 会話履歴を取得する、**Then** 空の配列またはセッション初期化メッセージのみが返される

---

### User Story 4 - 簡易チャットUI (Priority: P3)

エンジニアリングマネージャーが、ブラウザからチャットUIを通じて対話的に要件を入力できる。curlよりも直感的なインターフェースで会話を進められる。

**Why this priority**: API（P1-P2）があれば基本機能は完結するが、UIがあることでユーザー体験が大幅に向上する。PROGRESS.mdのPhase 2-3計画に従い、対話機能の真価を体験可能にする。

**Independent Test**: ブラウザで`/`（ルートパス）にアクセスし、チャット画面が表示されること、メッセージ入力→送信→AI応答表示のフローが動作することを確認できる。

**Acceptance Scenarios**:

1. **Given** ブラウザでチャットUIにアクセスしている、**When** メッセージを入力してEnterキーまたは送信ボタンを押す、**Then** `/api/chat`にリクエストが送信され、AIの応答がチャット画面に追加表示される
2. **Given** 新規アクセス（セッションIDなし）、**When** 初回メッセージを送信する、**Then** 新しいセッションIDが生成され、localStorageに保存され、以降のメッセージで自動的に使用される
3. **Given** 過去にチャットを行ったブラウザ（localStorageにセッションID保存済み）、**When** ページをリロードする、**Then** 保存されたセッションIDが読み込まれ、過去の会話履歴が画面に表示される
4. **Given** チャット画面で複数のメッセージをやり取りしている、**When** 会話履歴をスクロールする、**Then** 過去のメッセージが時系列順（古い順）で表示され、ユーザーメッセージとAIメッセージが視覚的に区別される

---

### Edge Cases

- セッションIDが存在しない場合、404エラーを返すか、新規セッションとして扱うか？（推奨: 404エラー、明示的な新規作成を促す）
- 会話履歴が非常に長い場合（例: 100メッセージ以上）、すべてをLLMコンテキストに含めるか、要約するか？（推奨: 最新N件のみをコンテキストに含める、または要約機能を実装）
- KVストレージ障害時、会話履歴が読み込めない場合の挙動は？（推奨: エラーレスポンスを返し、ユーザーに再試行を促す）
- 同時に複数のメッセージが送信された場合（競合状態）、会話履歴の整合性をどう保つか？（解決済み: 楽観的並行制御、タイムスタンプ順序保証。UI側でFR-019により送信ボタン無効化で実質的な競合防止）

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは`POST /api/chat`エンドポイントを提供しなければならない
- **FR-002**: システムはリクエストボディに`sessionId`（オプション）と`message`（必須）を受け付けなければならない
- **FR-003**: `sessionId`が提供されない場合、システムは新しいセッションを作成し、UUIDv4形式のセッションIDを生成しなければならない
- **FR-004**: システムはセッションIDごとに会話履歴をKVストレージに保存しなければならない（各メッセージにタイムスタンプを付与し、時系列順序を保証する）
- **FR-005**: システムは過去の会話履歴全体をLLMのコンテキストとして使用し、文脈を理解した応答を生成しなければならない
- **FR-006**: システムは会話履歴をD1データベースの`messages`テーブルに永続化しなければならない（ベストエフォート型：D1保存失敗時もKV保存成功なら200を返し、失敗をログに記録する）
- **FR-007**: システムはセッション情報をD1データベースの`sessions`テーブルに保存しなければならない（ベストエフォート型：D1保存失敗時もKV保存成功なら200を返し、失敗をログに記録する）
- **FR-008**: システムはセッションの作成日時と最終更新日時を記録しなければならない
- **FR-009**: システムは会話が「仕様書生成」段階に達した際、Phase 1の`generateSpec`ワークフローを実行しなければならない
- **FR-010**: システムは`GET /api/chat/{sessionId}/history`エンドポイントを提供し、会話履歴を時系列順で返さなければならない
- **FR-011**: システムは会話履歴取得時、各メッセージに送信者（"user"または"assistant"）、内容、タイムスタンプを含めなければならない
- **FR-012**: システムはセッションIDが存在しない場合、404エラーを返さなければならない
- **FR-013**: システムはメッセージの最大長を100KB（Phase 1の要件入力と同等）に制限し、不正な制御文字（NULL文字など）を含むメッセージを拒否しなければならない
- **FR-014**: システムはKVストレージ読み込み失敗時、503 Service Unavailableエラーを返さなければならない
- **FR-015**: システムは会話履歴が50件を超えた場合、最新50件のみをLLMコンテキストに含めなければならない（古いメッセージはD1に永続化されているが、LLMコンテキストからは除外される）
- **FR-016**: システムはCloudflare Pagesで静的HTMLチャットUIを提供しなければならない
- **FR-017**: UIはセッションIDをlocalStorageに保存し、ページリロード時に自動的に復元しなければならない
- **FR-018**: UIはユーザーメッセージとAIメッセージを視覚的に区別して表示しなければならない（メッセージ内容はHTMLエスケープ処理を行い、XSS攻撃を防ぐ）
- **FR-019**: UIはメッセージ送信中にローディング表示を行い、送信ボタンを無効化しなければならない
- **FR-020**: UIはエラー発生時（404, 503など）にユーザーにわかりやすいエラーメッセージを表示しなければならない
- **FR-021**: システムは主要な操作（セッション作成、メッセージ送受信、エラー発生）を構造化ログに記録しなければならない（ログレベル：Info/Error、含める情報：セッションID、タイムスタンプ、操作内容、エラー詳細）

### Key Entities

- **Session（セッション）**: ユーザーとAIの一連の会話を表す。セッションID（UUID）、作成日時、最終更新日時、関連するメッセージ群を含む。Phase 1の`spec`レコードと1対多の関係（1セッションから複数の仕様書バージョンが生成される可能性）。
- **Message（メッセージ）**: セッション内の個別の発言。送信者（user/assistant）、内容（テキスト）、タイムスタンプ、所属セッションIDを含む。会話履歴の基本単位。
- **ChatContext（チャット文脈）**: LLMに渡される会話履歴のスナップショット。複数のMessageを時系列順に結合したもの。KVから読み込まれ、Mastraワークフローに渡される。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: エンジニアリングマネージャーが初回メッセージ送信から5秒以内にAI応答を受け取ることができる
- **SC-002**: セッション内で10回以上のメッセージ交換を行った場合でも、各応答が5秒以内に返される
- **SC-003**: 過去のセッションを再開した際、会話履歴の読み込みから応答生成まで8秒以内に完了する
- **SC-004**: セッションごとに最大100件のメッセージを保存できる
- **SC-005**: 同時に10個の異なるセッションが並行して会話を続けられる（Phase 1と同じスケール目標）
- **SC-006**: 会話履歴取得APIが200ms以内にレスポンスを返す
- **SC-007**: ユーザーが対話を通じて要件を精緻化した結果、生成される仕様書の品質（完全性・明確性）がPhase 1の単発入力と比較して向上する（主観的評価だが、明確化質問の数や仕様書の詳細度で測定可能）
- **SC-008**: ユーザーがUIからメッセージを送信してから応答が画面に表示されるまで6秒以内に完了する（API応答5秒 + UI描画1秒）
- **SC-009**: UIはレスポンシブデザインで、スマートフォンでも基本的なチャット操作が可能である

## Assumptions

- セッションの有効期限は設定せず、永続的に保存する（Phase 4以降でアーカイブ・削除機能を追加予定）
- メッセージ1件あたりの最大サイズは100KB（Phase 1の要件入力と同等、詳細な要件や複数質問への回答を1メッセージで送信可能）
- 会話履歴が50件を超えた場合、最新50件のみをLLMコンテキストに含める（Geminiのトークン制限とレスポンス時間を考慮）。古いメッセージはD1に永続化されており、会話履歴API経由で取得可能
- KVストレージは高可用性を前提とし、障害時は503エラーで再試行を促す
- セッションIDはクライアント側で保持され、Cookie、localStorage、またはアプリケーション状態として管理される（Phase 2ではサーバー側の認証・セッション管理は実装しない）
- 会話の自然終了判定は実装せず、ユーザーが明示的に「仕様書を生成」を指示するまで対話を続ける
- Phase 1の`/api/spec`エンドポイントは残し、Phase 2の`/api/chat`と並行して提供する（後方互換性）

## Dependencies

- Phase 1完了（`/api/spec`エンドポイント、Mastra generateSpecワークフロー、D1 specs テーブル）
- KVストレージ（`DEV_ARCHITECT_SESSIONS`バインディング）が設定済み
- D1データベース（`dev_architect_db`）が設定済み
- Mastra対話型ワークフロー実装（Phase 1の単発ワークフローを拡張）

## Out of Scope

- 高度なUI機能（マークダウンレンダリング、コードハイライト、メッセージ編集・削除）
- ユーザー認証・認可（Phase 2では匿名セッション、Phase 4以降で実装）
- セッション間の共有・コラボレーション機能
- 会話履歴の全文検索機能
- 音声入力対応（Constitution原則Ⅲで将来実装予定だが、Phase 2では対象外）
- 仕様書の差分比較・バージョン管理（Phase 3以降）
- セッションのアーカイブ・削除機能（Phase 4以降）
